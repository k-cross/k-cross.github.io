<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>Three Phase Commit Data Migrations</title><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Signika&display=swap" rel=stylesheet><style>body{--primary-color:#698bcf;--primary-pale-color:#698bcf1c;--text-color:#3c4043;--text-pale-color:#9aa2b9;--bg-color:#fff;--highlight-mark-color:#5f75b045;--callout-note-color:#698bcf;--callout-important-color:#9971d9;--callout-warning-color:#c99054;--callout-alert-color:#d35757;--callout-question-color:#4985a2;--callout-tip-color:#3ea06f;--main-font:'Signika',ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:750px;--main-max-width:750px;--avatar-size:70px;--paragraph-font-size:18px;--paragraph-line-height:1.75;--aside-font-size:16px;--img-border-radius:0;--inline-code-border-radius:2px}body.dark{--primary-color:#698bcf;--primary-pale-color:#698bcf1c;--text-color:#9197a5;--text-pale-color:#5d6470;--bg-color:#202124;--highlight-mark-color:#5f75b045;--callout-note-color:#698bcf;--callout-important-color:#9971d9;--callout-warning-color:#c99054;--callout-alert-color:#d35757;--callout-question-color:#4985a2;--callout-tip-color:#3ea06f}</style><link href=/main.css rel=stylesheet><link href=/hl-light.css id=hl rel=stylesheet><body class=post><script>if(localStorage.getItem('theme')=='dark'){document.body.classList.add('dark');const a=document.querySelector('link#hl');if(a)a.href='/hl-dark.css'}</script><header class=blur><div id=header-wrapper><nav><a href=/>kmc</a><button aria-label="toggle expand" class=separator id=toggler>::</button><span class="wrap left fold">{</span><a href=/blog>blog</a><span class="wrap-separator fold">,</span><a class=fold href=/projects>projects</a><span class="wrap right fold">} ;</span></nav><div id=btns><a aria-label="rss feed" href=/blog/feed.xml><svg class="w-6 h-6" viewbox="0 0 24 24" fill=none stroke=currentColor stroke-width=1.5 xmlns=http://www.w3.org/2000/svg><path d="M12.75 19.5v-.75a7.5 7.5 0 00-7.5-7.5H4.5m0-6.75h.75c7.87 0 14.25 6.38 14.25 14.25v.75M6 18.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0z" stroke-linecap=round stroke-linejoin=round /></svg></a><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
</svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
</svg>' id=theme-toggle><svg class="w-6 h-6" viewbox="0 0 24 24" fill=none stroke=currentColor stroke-width=1.5 xmlns=http://www.w3.org/2000/svg><path d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" stroke-linecap=round stroke-linejoin=round /></svg></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><div id=wrapper><div id=blank></div><aside class=blur><nav><ul><li><a class=h2 href=#assemble-phase>Assemble Phase</a><li><a class=h2 href=#manipulation-phase>Manipulation Phase</a><li><a class=h2 href=#dismantle-phase>Dismantle Phase</a><li><a class=h2 href=#all-good-things>All Good Things</a></ul></nav><button aria-label="back to top" id=back-to-top><svg class="w-6 h-6" viewbox="0 0 24 24" fill=none stroke=currentColor stroke-width=1.5 xmlns=http://www.w3.org/2000/svg><path d="M12 19.5v-15m0 0l-6.75 6.75M12 4.5l6.75 6.75" stroke-linecap=round stroke-linejoin=round /></svg></button></aside><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" />
</svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184" />
</svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 19.5l-15-15m0 0v11.25m0-11.25h11.25" />
</svg>' class=prose><h1>Three Phase Commit Data Migrations</h1><div id=post-info><div id=date><span id=publish>2018-12-09</span><span>Updated on <span id=updated>2020-07-16</span></span></div><div id=tags><a href=https://k-cross.github.io/tags/technique><span>#</span>technique</a><a href=https://k-cross.github.io/tags/engineering><span>#</span>engineering</a></div></div><p>Paving a path towards continuous delivery and zero-downtime deployments is a challenging pursuit especially when each project employs its own strategy. One generic solution that is at the heart of this article was inspired by the three-phase-commit. Its origin stems from <em>computer networking</em> as a way to perform the non-blocking version of the two-phase commit protocol, described as:<ol><li>voting phase: a coordinator prepares all transaction participants, signaling to proceed until either committing or aborting.<li>commit phase: depending on participant votes, the coordinator decides to <em>commit</em> if all voted <em>agree</em> otherwise it <em>aborts</em> and notifies all participants.</ol><p>Adapting these to web applications, the <em>contention</em> for <em>resources</em> occurs with respect to databases and long-lived state. Taking downtime is commonly due to blocking operations from locking mechanisms over shared resources. To ensure the stability of an application's environment while updating, taking downtime will guarantee <em>state</em> remains consistent for all services and users. Since causes for downtime can be determined in advance, using more sophisticated approaches to eliminate it is possible. Executing data migrations as three distinct phases is a generic approach that anyone can use as a stone to pave in the road to zero-downtime deployments.<h2 id=assemble-phase>Assemble Phase<a aria-label="Anchor link for: assemble-phase" class=zola-anchor href=#assemble-phase>#</a></h2><p>The first phase involves the creation of new entities which usually means new tables or columns with respect to a database. When a new entity replaces an old one the use of dual writes and idempotent operations is an effective strategy. Dual writes are when both old and new entities are recorded in the database alongside the running application. It allows changes to happen in production while still being able to roll-back those changes to the old model should the need arise. This increases the reliability that the updates work as intended and without issue. Making the new entity operations idempotent is also very valuable in many cases as we'll find in the next phase. For an application, data structures that replace old ones are a common source failure. By the creation of an idempotent legacy handler, it's possible to create a version chain that's able to turn an old structure into a new one reliably. Having multiple versions of data and data structures is not ideal, but it is not always practical to migrate all data in one shot. By having a type of JIT version update in place, it's possible to avoid complexities around more sophisticated data migrations.<h2 id=manipulation-phase>Manipulation Phase<a aria-label="Anchor link for: manipulation-phase" class=zola-anchor href=#manipulation-phase>#</a></h2><p>Back-filling data into a newly created column is the essence of this phase. Processing data only requires a read from an old entity and a write to the new one. How those writes are performed matters greatly. The trivial approach to writing a data migration is to do everything in one shot with no roll-back plan. It's not always possible or at least practical to build database roll-back plans. When failures occur with single pass migrations, they can be very expensive. The database might have locked some critical columns with a large number of rows. So whatever the downtime is for a successful operation always needs to be planned to be double just in case a rollback is required.<p>Alternatively, when writing operations are made idempotent the application can be made eventually consistent. Since dual writing new data is already occurring, backfilling old data into the new format using an idempotent write operation allows the application to fail safely. A write might fail for many reasons -- junk data, unexpected formats, and mishandled cases. Imagine having the first $$75%$$ of a migration be performed and then fail on a single valid case. There are a few potential issues here:<ol><li>the backfill task is performed as a migration<li>the backfill task is performed as a transaction<li>the backfill task is not idempotent</ol><p>The first case has the flaw of downtime. The second issue may be computationally expensive and infeasible to repeatedly perform. The last issue creates potential for duplicated data during the backfill process. Using the idempotent strategy is more manageable since backfilling doesn't need to occur all at once. If multiple write operations do happen, they end in the same result. Flexible data migrations are the result. Migrations can be written so that they're performed in one shot or done as batch jobs. The failure handling mechanisms can also be as simple or complex as desired. For instance, using a trivial approach to retry the entire backfill or a sophisticated one to pick up where it left off.<h2 id=dismantle-phase>Dismantle Phase<a aria-label="Anchor link for: dismantle-phase" class=zola-anchor href=#dismantle-phase>#</a></h2><p>This is equivalent to dropping an entity from the database. With the completion of the <em>manipulation phase</em>, getting verification that the backfill is complete is necessary to confirm the entity is no longer required. All the code that handled the updates and branching paths that resulted from different version functions can be removed too. There's no better feeling as an engineer than reducing all the complexity of a system by removing the bloat and scaffolding that's no longer needed.<h2 id=all-good-things>All Good Things<a aria-label="Anchor link for: all-good-things" class=zola-anchor href=#all-good-things>#</a></h2><p>A final word of caution. Application code updates only work reliably when the state of the application can be rebuilt and executed in the event of a crash. One approach is to build a history from immutable states which can be replayed, basically a log in the way some file systems work. If the behavior of an application is determined by global state that cannot be restored reliably, larger problems exist and this strategy is unlikely to help. Other problems that were not covered include the existence of operating on data across different databases. This is a much harder distributed systems problem to solve but using idempotent operations is a great place to start.<p>The three phase commit strategy has worked on production systems for a few years in a variety of different scenarios. Previously, deployments would happen during the odd hours of evening in order to cause minimal disruption. Zero-downtime deployments can happen during sane working ours bringing joy to engineers, more certainty to stake holders, and a better experience for customers. All good things result for all parties that have a lot to loose when things go wrong.</article><div class=giscus></div></div><footer><div class=copyright><p>© 2023 KMC</div></footer></main></div><script src=/js/lightense.min.js></script><script src=/js/main.js></script>