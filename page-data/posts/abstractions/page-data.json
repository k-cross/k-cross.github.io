{"componentChunkName":"component---src-templates-post-tsx","path":"/posts/abstractions/","result":{"data":{"markdownRemark":{"html":"<p>Correct abstractions in programming are hard to make for the future case.\nOften, there is not enough data at the start of a project when the problem space is not well understood.\nThis makes development harder due to the volatility of projects, showing that it’s unlikely to make meaningful predictions further into the future.\nSo how then, should sustainable programs be built?\nOptimizing for code deletion is one strategy worth utilizing since it’s forward moving flexibility that’s the real goal.\nIn essence, being unconstrained from the past, the future can be built unencumbered, thus reducing effort.\nThe following emergent traits tend to result:</p>\n<ol>\n<li>a modular type of architecture</li>\n<li>extending features takes less effort</li>\n<li>code base is more optimized for the current running state rather than the predicted future state</li>\n</ol>\n<h2>Grabbing an Axe</h2>\n<p>One of the more satisfying things in programming is utilizing a razor-sharp axe and cutting a code base down to size!\nGrokking a system is far easier when it’s simple, well designed, and small.\nHow better, to understand a system than by focusing on cutting stuff out of it?\nWhen emphasis is placed on deletion it’s paramount to understand the system’s complexity and nuances at the boundaries.\nThis calls for the need to have equivalency tests available to the systems that are intended to be replaced.\nEquivalence testing is the only real hope to allowing a proper rewrite.\nIt’s an uneasy feeling to delete code that’s not well understood.\nBeing able to verify that those changes do what’s expected is critical — the path to the new system needs to be trustworthy.\nThere’s a fine line between tests that mock what you expect versus checking the expected behavior of a <em>system/function/method</em>.\nGetting the system behavior correct is mandatory, even the undesirable behavior that is thought of as broken internally, because customers probably rely on the broken behavior making them features.</p>\n<p>Deletion promotes modularity and the clarity of application contracts.\nBeing able to remove things comfortably means that the core logic of isolated features are successfully decoupled from the core logic of other components of the system.\nDeleting a feature should cause its tests to fail, but those tests ideally wouldn’t affect the behavior of other tests other than related subcomponent.\nTests reveal a starting point in which to add new features once code has been deleted, or at least where more care needs to be placed.\nTests pave the way to automate and verify the behavior of what deletion does.\nOptimizing for deletion enforces modularity because scaling quickly in a large code base demands it.\nThe easiest way to verify integrity is by isolation, testing isolated components, and then testing the interoperability of the system as a whole.\nIn order to do this reliably, avoid side-effects, as they’ll cause additional complexity as well as combinatorial growth of the testable problem space.\nModularity is the core component in optimizing for deletion.\nIt allows for the most flexibility during the reimplementation a feature since the interfaces remain largely unchanged.\nFor instance, a billing system shouldn’t be tied to a metric system other than by interfaces, otherwise swapping out one or the other makes it a very time intensive project and the end result will almost certainly be a modular system that replaces it.\nNot convinced?\nImagine that the billing system is a third-party service?\nWhat happens when that third-party changes its usage policy in a highly undesirable way?\nHow much effort is required to swap implementations?</p>\n<h2>Embracing the Void</h2>\n<p>What does the absence of code buy?\nThe flexibility to extend the system with fewer legacy restrictions.\nTo some degree, legacy requirements are always going to linger, but they should be external customer facing legacy issues, not internal system constraints.\nAPIs are very hard to not be constrained by.\nNew features are much easier to write when all the other interfaces that they’ll rely on can also be changed and modified easily.\nWith a modular code base, new features can be developed and tested in isolation and then added into the system through an interface.</p>\n<p>Optimizing for deletion reduces the scope of development to the minimal requirements rather than predictions.\nThe consequences of deletion create some very desirable traits.\nTheir drawbacks come from the necessity to perform deletions reliably, which are not trivial.</p>\n<h2>Vectors</h2>\n<p>This idea is not without its drawbacks.\nInitial development velocity for example, is not a trait since it’s impossible to rebuild nontrivial features reliably.\nTaking this philosophy to its extremes, like any other philosophy, is inane.\nFeature implementations are like vector math, where there are different paths that can be taken but there’s a single optimal route from point A to point B.\nKeeping the mentioned traits in mind helps strike a balance as a guide post to do it properly.\nImproper utilization can occur when a feature is easy enough to extend rather than write from scratch.\nToo many <em>time/space</em> optimizations probably results in very inflexible code which can easily become coupled with other components for the sake of efficiency.\nSometimes it’s warranted, sometimes it’s not.\nWhile it’s a good idea to think about current use cases, obvious future cases like extending an API, should remain flexible enough to not have to be rewritten every time a feature is requested.</p>\n<p>At the end of the day,</p>\n<div class=\"gatsby-highlight\" data-language=\"git\"><pre class=\"language-git\"><code class=\"language-git\">83 files changed, 1716 insertions(+), 19478 deletions(-)</code></pre></div>\n<p>if this doesn’t put a smile on your face, you’re probably a masochist.</p>\n<p><em>NOTE: when referring to testing I mean that in the general sense, not specifically unit testing</em></p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Correct abstractions in programming are hard to make for the future case.\nOften, there is not enough data at the start of a project when the problem space is not well understood.\nThis makes development harder due to the volatility of projects, showing that it’s unlikely to make meaningful predictions further into the future.\nSo how then, should sustainable programs be built?\nOptimizing for code deletion is one strategy worth utilizing since it’s forward moving flexibility that’s the real goal.\nIn essence, being unconstrained from the past, the future can be built unencumbered, thus reducing effort.\nThe following emergent traits tend to result:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"a modular type of architecture"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"extending features takes less effort"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"code base is more optimized for the current running state rather than the predicted future state"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Grabbing an Axe"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One of the more satisfying things in programming is utilizing a razor-sharp axe and cutting a code base down to size!\nGrokking a system is far easier when it’s simple, well designed, and small.\nHow better, to understand a system than by focusing on cutting stuff out of it?\nWhen emphasis is placed on deletion it’s paramount to understand the system’s complexity and nuances at the boundaries.\nThis calls for the need to have equivalency tests available to the systems that are intended to be replaced.\nEquivalence testing is the only real hope to allowing a proper rewrite.\nIt’s an uneasy feeling to delete code that’s not well understood.\nBeing able to verify that those changes do what’s expected is critical — the path to the new system needs to be trustworthy.\nThere’s a fine line between tests that mock what you expect versus checking the expected behavior of a "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"system/function/method"}]},{"type":"text","value":".\nGetting the system behavior correct is mandatory, even the undesirable behavior that is thought of as broken internally, because customers probably rely on the broken behavior making them features."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Deletion promotes modularity and the clarity of application contracts.\nBeing able to remove things comfortably means that the core logic of isolated features are successfully decoupled from the core logic of other components of the system.\nDeleting a feature should cause its tests to fail, but those tests ideally wouldn’t affect the behavior of other tests other than related subcomponent.\nTests reveal a starting point in which to add new features once code has been deleted, or at least where more care needs to be placed.\nTests pave the way to automate and verify the behavior of what deletion does.\nOptimizing for deletion enforces modularity because scaling quickly in a large code base demands it.\nThe easiest way to verify integrity is by isolation, testing isolated components, and then testing the interoperability of the system as a whole.\nIn order to do this reliably, avoid side-effects, as they’ll cause additional complexity as well as combinatorial growth of the testable problem space.\nModularity is the core component in optimizing for deletion.\nIt allows for the most flexibility during the reimplementation a feature since the interfaces remain largely unchanged.\nFor instance, a billing system shouldn’t be tied to a metric system other than by interfaces, otherwise swapping out one or the other makes it a very time intensive project and the end result will almost certainly be a modular system that replaces it.\nNot convinced?\nImagine that the billing system is a third-party service?\nWhat happens when that third-party changes its usage policy in a highly undesirable way?\nHow much effort is required to swap implementations?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Embracing the Void"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"What does the absence of code buy?\nThe flexibility to extend the system with fewer legacy restrictions.\nTo some degree, legacy requirements are always going to linger, but they should be external customer facing legacy issues, not internal system constraints.\nAPIs are very hard to not be constrained by.\nNew features are much easier to write when all the other interfaces that they’ll rely on can also be changed and modified easily.\nWith a modular code base, new features can be developed and tested in isolation and then added into the system through an interface."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Optimizing for deletion reduces the scope of development to the minimal requirements rather than predictions.\nThe consequences of deletion create some very desirable traits.\nTheir drawbacks come from the necessity to perform deletions reliably, which are not trivial."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Vectors"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This idea is not without its drawbacks.\nInitial development velocity for example, is not a trait since it’s impossible to rebuild nontrivial features reliably.\nTaking this philosophy to its extremes, like any other philosophy, is inane.\nFeature implementations are like vector math, where there are different paths that can be taken but there’s a single optimal route from point A to point B.\nKeeping the mentioned traits in mind helps strike a balance as a guide post to do it properly.\nImproper utilization can occur when a feature is easy enough to extend rather than write from scratch.\nToo many "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"time/space"}]},{"type":"text","value":" optimizations probably results in very inflexible code which can easily become coupled with other components for the sake of efficiency.\nSometimes it’s warranted, sometimes it’s not.\nWhile it’s a good idea to think about current use cases, obvious future cases like extending an API, should remain flexible enough to not have to be rewritten every time a feature is requested."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"At the end of the day,"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"git"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-git"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-git"]},"children":[{"type":"text","value":"83 files changed, 1716 insertions(+), 19478 deletions(-)"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"if this doesn’t put a smile on your face, you’re probably a masochist."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"NOTE: when referring to testing I mean that in the general sense, not specifically unit testing"}]}]}],"data":{"quirksMode":false}},"excerpt":"Correct abstractions in programming are hard to make for the future case.\nOften, there is not enough data at the start of a project when the…","timeToRead":4,"frontmatter":{"title":"Abstractions","userDate":"4 July 2018","date":"2018-07-04T07:06:38.000Z","modified":"2020-07-16T07:06:38.000Z","tags":["Opinion","Software Engineering"],"excerpt":"Reflecting on \"The Art of Destroying Software\" by Greg Young","picture":null,"author":[{"id":"quasarken","bio":"Software Engineer","avatar":{"children":[{"__typename":"ImageSharp","fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAABCUlEQVQ4y2MQVdQiGzEMJ80iCppwBOcSpRlZHZop+DSLKWnzS6v0Tpl5/da9E2cuXL1xZ/6SlXxSyvOXrlq8cp2ArBpBzaqNnX1HT57Zvmf/4ROnJk6fwyutMnHG3GlzFgri1wxBAjKqQPthSBXoYIgIUc7umTT96vVbJ06fO3X2AhABGZev3Zgxb5GwvAYhzTJAZ/cfPXF2595Duw8cASIg4/Dx072TZxLQjOFsVTCCeoEoZ3dPnH7l2q1zF6+6BYSbO3mdPnfp8tWb0+cuEiLsbGnV5q4Jx8+cO3TspLNviKmD+/4jx4+dPtc/bRZRzhaSUxeUUwMioGphBU0IW1BOfZjnKnpoBgBuRuAIvQwT7gAAAABJRU5ErkJggg==","aspectRatio":1,"src":"/static/7ffe238930a689e103d70f234bb00199/3891b/ghost.png","srcSet":"/static/7ffe238930a689e103d70f234bb00199/22f7f/ghost.png 40w,\n/static/7ffe238930a689e103d70f234bb00199/587c9/ghost.png 80w,\n/static/7ffe238930a689e103d70f234bb00199/d966b/ghost.png 120w,\n/static/7ffe238930a689e103d70f234bb00199/3891b/ghost.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}]}}]}},"relatedPosts":{"totalCount":3,"edges":[{"node":{"id":"df577b23-9e63-5bcf-b91d-a707c096d69b","timeToRead":4,"excerpt":"In a magical world where all tasks are well defined, performing task  or implement feature  is a simple matter of doing.\nIn this world only…","frontmatter":{"title":"Osmosis Driven Development","date":"2018-10-29T14:59:41.000Z","modified":"2020-08-08T07:06:38.000Z"},"fields":{"slug":"/posts/osmosis/"}}},{"node":{"id":"b9afcb20-4a42-5ffd-b710-20e55b5009e4","timeToRead":4,"excerpt":"I’ve had the luxury of programming with elixir for the last nine months.\nIt’s been my first full-time experience utilizing a functional…","frontmatter":{"title":"Elixir Impressions","date":"2018-07-07T07:36:24.000Z","modified":null},"fields":{"slug":"/posts/elixir_impressions/"}}},{"node":{"id":"80fc7aae-0f10-537f-b598-4892d1975094","timeToRead":4,"excerpt":"Correct abstractions in programming are hard to make for the future case.\nOften, there is not enough data at the start of a project when the…","frontmatter":{"title":"Abstractions","date":"2018-07-04T07:06:38.000Z","modified":"2020-07-16T07:06:38.000Z"},"fields":{"slug":"/posts/abstractions/"}}}]}},"pageContext":{"slug":"/posts/abstractions/","prev":null,"next":{"excerpt":"I’ve had the luxury of programming with elixir for the last nine months.\nIt’s been my first full-time experience utilizing a functional…","timeToRead":4,"frontmatter":{"title":"Elixir Impressions","tags":["Opinion","Software Engineering"],"date":"2018-07-07T07:36:24.000Z","draft":false,"excerpt":"TLDR: Elixir is awesome!!!","picture":null,"author":[{"id":"quasarken","bio":"Software Engineer","avatar":{"children":[{"fluid":{"aspectRatio":1,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAABCUlEQVQ4y2MQVdQiGzEMJ80iCppwBOcSpRlZHZop+DSLKWnzS6v0Tpl5/da9E2cuXL1xZ/6SlXxSyvOXrlq8cp2ArBpBzaqNnX1HT57Zvmf/4ROnJk6fwyutMnHG3GlzFgri1wxBAjKqQPthSBXoYIgIUc7umTT96vVbJ06fO3X2AhABGZev3Zgxb5GwvAYhzTJAZ/cfPXF2595Duw8cASIg4/Dx072TZxLQjOFsVTCCeoEoZ3dPnH7l2q1zF6+6BYSbO3mdPnfp8tWb0+cuEiLsbGnV5q4Jx8+cO3TspLNviKmD+/4jx4+dPtc/bRZRzhaSUxeUUwMioGphBU0IW1BOfZjnKnpoBgBuRuAIvQwT7gAAAABJRU5ErkJggg==","sizes":"(max-width: 400px) 100vw, 400px","src":"/static/7ffe238930a689e103d70f234bb00199/3891b/ghost.png","srcSet":"/static/7ffe238930a689e103d70f234bb00199/8ac63/ghost.png 200w,\n/static/7ffe238930a689e103d70f234bb00199/3891b/ghost.png 400w"}}]}}]},"fields":{"layout":"post","slug":"/posts/elixir_impressions/"}},"primaryTag":"Opinion"}},"staticQueryHashes":[]}