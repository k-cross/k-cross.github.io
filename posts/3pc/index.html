<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    
    <meta name="description" content="Abstractions from madness!">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:domain" content="https://k-cross.github.io">
    
    <meta name="twitter:image" content="https://k-cross.github.io/gallery/images/console.png">
    <meta name="twitter:title" property="og:title" itemprop="title name" content="kurosu">
    <meta name="twitter:description" property="og:description" itemprop="description" content="Abstractions from madness!">
    <meta name="og:type" content="website">
    <meta name="og:url" content="https://k-cross.github.io">
    <meta name="og:image" itemprop="image primaryImageOfPage" content="https://k-cross.github.io/gallery/images/console.png">
    
    <title>Three Phase Commit</title>
    <link rel="shortcut icon" href="https://k-cross.github.io/sam.ico" id="favicon">
    <link rel="stylesheet" href="https://k-cross.github.io/css/style.css">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">
    
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous"></script>
    
    

</head>

</html>
<body><div class="wrap"><div class="section" id="title">Three Phase Commit</div><div class="section" id="content">Sun Dec 09, 2018 &#183; 764 words

<div><span id="tag"><a href="https://k-cross.github.io/tags/data-migrations">data migrations</a></span><span id="tag"><a href="https://k-cross.github.io/tags/software-engineering">software engineering</a></span><span id="tag"><a href="https://k-cross.github.io/tags/programming">programming</a></span><span id="tag"><a href="https://k-cross.github.io/tags/zero-downtime">zero downtime</a></span></div><hr/>

<p>Paving a path towards continuous delivery and zero downtime deployments is a challenging pursuit.
It seems that each organization has a different strategy to employ and different techniques to use.
One of the more generic solutions that is at the heart of this article was inspired by the three-phase-commit.
Its origin stems from <em>computer networking</em>.
It&rsquo;s a way to perform the non-blocking version of the two-phase commit protocol, described as:</p>

<ol>
<li>The voting phase: a coordinator tries to prepare all the transaction&rsquo;s participants, communicating to proceed until either committing or aborting.</li>
<li>The commit phase: depending on participant votes, the coordinator decides to commit if all voted <em>agree</em> otherwise it <em>aborts</em> and notifies all participants.</li>
</ol>

<p>Unlike networking however, we care about <em>contention</em> for <em>resources</em> with respect to databases and long-lived state in memory.
Taking downtime is commonly caused by blocking actions from locking mechanisms with respect to a common resource.
Another reason for taking downtime is to ensure the stability of the environment upon an update to refresh the <em>state</em> of application processes.
Since causes for downtime can often be determined they can be planned around.</p>

<h2 id="construction-phase">Construction Phase</h2>

<p>The first phase with respect to applications and databases deals with the creation or generation of a new entity.
In a database, this might mean a new table or column.
If the new entity is meant to replace on old entity then dual writing is the first step to take.
This is when both new and old entities are recorded in the database alongside the running application as normal.
If the new entity has no requirement on an existing entity then its business as usual.
In an application, a new data structure intended to replace an old one is a common source failure.
The application strategy would be to create a legacy handler that&rsquo;s able to turn an old structure into a new one.</p>

<h2 id="renovation-phase">Renovation Phase</h2>

<p>Back-filling data into a newly created column is the essence of this phase.
Copying data from one place to another and perhaps processing the data only requires a read from an old entity and a write to a now pre-existing but new one.
It&rsquo;s unlikely this will create a high contention lock.
This strategy is more manageable since back-filling doesn&rsquo;t need to occur all at once.
Instead, they can be batched into stages in case a lock is required to perform the operation.
This makes timeouts unlikely to occur but it might make users temporarily experience longer waits.
When a database migration is too expensive, the <em>legacy handler</em> becomes useful.
The <em>handlers</em> operate by shaping different input into a uniform output.
It might be desirable to update the data then persist the change but that might lead to the belief that the legacy code handler can be deleted prematurely.
Removal is valid if every entity has been updated or if the old data is no longer supported.
A way to mitigate this problem is <em>data compaction</em>, which is a way to make old and new data look like the same thing.</p>

<h2 id="dismantle-phase">Dismantle Phase</h2>

<p>This is equivalent to dropping an entity from the database.
It&rsquo;s easy to do once it&rsquo;s truly no longer required and by this phase it should not be, but a way to confirm that this is the case may ease the nerves or help get buy in.
In an application, the process life cycle might live long, but this is essentially getting rid of <em>legacy handlers</em> and <em>versioned functions</em>.
When code complexity starts to become a problem or the legacy data handlers are preventing desirable features from happening, this is when its time to start considering data compaction.</p>

<h2 id="all-good-things">All Good Things</h2>

<p>A final word of caution.
When dealing with application code updates, these only work reliably when the state of the application can be rebuilt and executed even in the event of a crash.
One approach is to build a history from immutable states which can be replayed.
If the behavior of an application is determined by global state that cannot be restored reliably, there may be larger problems at play, but this strategy is unlikely to help.</p>

<p>For the last year, this strategy has worked in production.
Previously, deployments would happen during the odd hours of evening in order to cause minimal disruption.
The reason why zero-downtime deployments are nice is because they bring more certainty to stake holders and allow engineering to deploy during sane hours.
It should catch mistakes earlier in the process, usually before a deployment.
This brings all the good things for all parties that have a lot to loose when things go wrong.</p>
</div><div class="section bottom-menu"><hr/><p>
<a href="/posts">back</a>
 &#183;



<a href="/about">who?</a>


&#183; <a href="/posts">what?</a>
&#183; <a href="/purpose">why?</a>

&#183; <a href="https://k-cross.github.io">main</a></p></div><div class="section footer">Abstractions from madness!</div></div></body>