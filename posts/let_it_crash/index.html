<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    
    <meta name="description" content="Abstractions from madness!">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:domain" content="https://k-cross.github.io">
    
    <meta name="twitter:image" content="https://k-cross.github.io/gallery/images/console.png">
    <meta name="twitter:title" property="og:title" itemprop="title name" content="kurosu">
    <meta name="twitter:description" property="og:description" itemprop="description" content="Abstractions from madness!">
    <meta name="og:type" content="website">
    <meta name="og:url" content="https://k-cross.github.io">
    <meta name="og:image" itemprop="image primaryImageOfPage" content="https://k-cross.github.io/gallery/images/console.png">
    
    <title>Everything You Ever Wanted to Know About Crashing</title>
    <link rel="shortcut icon" href="https://k-cross.github.io/sam.ico" id="favicon">
    <link rel="stylesheet" href="https://k-cross.github.io/css/style.css">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic">
    
    <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous"></script>
    
    

</head>

</html>
<body><div class="wrap"><div class="section" id="title">Everything You Ever Wanted to Know About Crashing</div><div class="section" id="content">Tue Jul 10, 2018 &#183; 742 words

<div><span id="tag"><a href="https://k-cross.github.io/tags/error-handling">error handling</a></span><span id="tag"><a href="https://k-cross.github.io/tags/elixir-examples">elixir examples</a></span><span id="tag"><a href="https://k-cross.github.io/tags/programming">programming</a></span></div><hr/><p>Being able to just crash an ill running process is awesome.
No need to handle it, no need to <code>kill -9</code> a pesky service because of a buggy system call handler.
Just a nice old fashioned death.
This comes from <em>erlang&rsquo;s let it crash</em> philosophy.
But this is about the times when dying is less than desirable.</p>

<p>Why should a process be able to crash and when should it?
They should crash when they&rsquo;re not expected to handle failure.
They&rsquo;re able to crash because they run in isolated tasks with independent memory spaces that can be restarted and run to completion, or just killed.
The thing that makes crashing desirable in the first place is the fact that the correct result either doesn&rsquo;t matter or will result regardless.</p>

<p>What happens when a failure occurs but a user&rsquo;s expecting a response?</p>

<blockquote>
<p>User: WTF is going on?
Programmer: \_(ãƒ„)_/</p>
</blockquote>

<p>Any blocking system call that a user directly relies upon should be handled, whether it&rsquo;s an error message for a non-technical user or a status code for an API consumer.
This doesn&rsquo;t matter for asynchronous calls since their errors can be handled with no user interaction.
Those wayward children can be thrown in a task supervisor and restarted.
In essence if a program needs to relay a message, error handling becomes a requirement.</p>

<p>This is all fine and dandy, but where should error handling code exist?
It&rsquo;s quite easy in functional languages like <em>erlang/elixir</em> to handle error cases because of pattern matching.
For instance:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir">val1 <span style="color:#f92672">=</span> <span style="color:#e6db74">:some_value</span>

<span style="color:#75715e"># Response to some blocking client call</span>
with <span style="color:#e6db74">:expected_result1</span> <span style="color:#f92672">=</span> val2 <span style="color:#f92672">&lt;-</span> fun1(val1),
     <span style="color:#e6db74">:expected_result2</span> <span style="color:#f92672">&lt;-</span> fun2(val2) do
  <span style="color:#e6db74">:expected_result</span>
end

def fun1(val) do
  case val do
    <span style="color:#e6db74">:some_value</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">:expected_result1</span>
    err <span style="color:#f92672">-&gt;</span> {<span style="color:#e6db74">:error</span>, <span style="color:#e6db74">&#34;Expected somthing else, got </span><span style="color:#e6db74">#{</span>inspect err<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>}
  end
end

def fun2(<span style="color:#e6db74">:expected_result1</span>), <span style="color:#e6db74">do</span>: <span style="color:#e6db74">:expected_result2</span>
def fun2(val), <span style="color:#e6db74">do</span>: {<span style="color:#e6db74">:error</span>, <span style="color:#e6db74">&#34;Some message&#34;</span>}</code></pre></div>
<p>Any error that happens in this function call pipeline simply redirects to it&rsquo;s function&rsquo;s error handler.
There are many ways to deal with error cases but pattern matching on expected results with a catch all on the unexpected ones (or the well known error cases for more tailored responses) create a robust foundation with clear acceptance criteria.
But notice, each function is handling errors here.
Using <code>with</code> here makes this cleaner since we don&rsquo;t need to handle errors in function calls, but handling errors inside each function is not ideal either.</p>

<p>Looking at a slightly more complicated example should demonstrate why.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir"><span style="color:#75715e"># Some more blocking code</span>
def blocking_call({<span style="color:#e6db74">:msg1</span>, val1}, <span style="color:#e6db74">:state</span>) do
  with val2 <span style="color:#f92672">=</span> val1 <span style="color:#f92672">&lt;-</span> fun1(val1),
       <span style="color:#e6db74">:expected_result2</span> <span style="color:#f92672">&lt;-</span> fun2(val2) do
    <span style="color:#e6db74">:expected_result</span>
  else
    err <span style="color:#f92672">-&gt;</span> handle_error(err)
  end
end

def blocking_call({<span style="color:#e6db74">:msg2</span>, val1}, <span style="color:#e6db74">:state</span>) do
  with <span style="color:#e6db74">:expected_result1</span> <span style="color:#f92672">=</span> val2 <span style="color:#f92672">&lt;-</span> fun1(val1),
       <span style="color:#e6db74">:expected_result2</span> <span style="color:#f92672">&lt;-</span> fun2(val2) do
    <span style="color:#e6db74">:expected_result</span>
  else
    err <span style="color:#f92672">-&gt;</span> handle_error(err)
  end
end

def handle_error({<span style="color:#e6db74">:error</span>, msg}), <span style="color:#e6db74">do</span>: {<span style="color:#e6db74">:error</span>, msg}
def handle_error(err) when is_atom(err), <span style="color:#e6db74">do</span>: {<span style="color:#e6db74">:error</span>, <span style="color:#e6db74">&#34;got unknown atom&#34;</span>}
def handle_error(err), <span style="color:#e6db74">do</span>: {<span style="color:#e6db74">:error</span>, <span style="color:#e6db74">&#34;generic msg&#34;</span>}

def fun1(val) do
  case val do
    <span style="color:#e6db74">:some_value</span> <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">:expected_result1</span>
    val <span style="color:#f92672">-&gt;</span> val
  end
end

def fun2(<span style="color:#e6db74">:expected_result1</span>), <span style="color:#e6db74">do</span>: <span style="color:#e6db74">:expected_result2</span>
def fun2(val), <span style="color:#e6db74">do</span>: {<span style="color:#e6db74">:error</span>, <span style="color:#e6db74">&#34;Some message&#34;</span>}</code></pre></div>
<p>The more that functions are shared, the more generic they&rsquo;re likely to get.
Generic functions should be focused on applying transformations rather than growing into giant error handlers.
Instead, just write code to handle the unexpected in a isolated and generic way, as a function itself.
Sure, it is not practical for every case but it&rsquo;s certainly nicer than rewriting similar error handling logic when it can be made generic.</p>

<p>Those were examples of direct calls from the client.
So that&rsquo;s straight forward enough, but is there a way to handle less errors in blocking code for complex interactions?
Of course!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-elixir" data-lang="elixir"><span style="color:#75715e"># Some more blocking code</span>
def blocking_call({<span style="color:#e6db74">:msg1</span>, val1}, <span style="color:#e6db74">:state</span>) do
  with val2 <span style="color:#f92672">=</span> val1 <span style="color:#f92672">&lt;-</span> fun1(val1),
       <span style="color:#e6db74">:expected_result2</span> <span style="color:#f92672">&lt;-</span> fun2(val2) do
       <span style="color:#e6db74">:ok</span> <span style="color:#f92672">&lt;-</span> extremely_long_running_function(val2) do
    <span style="color:#e6db74">:expected_result</span>
  else
    err <span style="color:#f92672">-&gt;</span> handle_error(err)
  end
end

...
def extremely_long_running_function(val) do
  <span style="color:#75715e"># Wraps program in async task handled by supervisor</span>
  ...
  <span style="color:#e6db74">:ok</span>
end</code></pre></div>
<p>The thing of interest is <code>:ok</code> is returned for the asynchronous call, regardless of its success, pawning off error handling and retry logic to the supervisor.
When a thing just needs to happen and no response is needed, then make it asynchronous.
Just because the client needs a response doesn&rsquo;t necessarily mean that the entire request needs to be blocking.</p>

<p>Hopefully this demonstrates the delegation of error handling to robust services and generic functions.
Obviously this will differ in implementation from language to language and project to project, but that&rsquo;s an exercise for the reader <code>;)</code>.</p>
</div><div class="section bottom-menu"><hr/><p>
<a href="/posts">back</a>
 &#183;



<a href="/about">who?</a>


&#183; <a href="/posts">what?</a>
&#183; <a href="/purpose">why?</a>

&#183; <a href="https://k-cross.github.io">main</a></p></div><div class="section footer">Abstractions from madness!</div></div></body>